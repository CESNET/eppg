/*
Modifications copyright 2017 CESNET

Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <chrono>
#include <ctime>

#include "fppProgram.h"
#include "fppType.h"
#include "fppParser.h"
#include "frontends/p4/coreLibrary.h"
#include "frontends/common/options.h"
#include <stdio.h>
namespace FPP {

bool FPPProgram::build() {
    auto pack = toplevel->getMain();
    if (pack->getConstructorParameters()->size() != 1) {
        ::error("Expected toplevel package %1% to have 1 parameter", pack->type);
        return false;
    }

    auto pb = pack->getParameterValue(model.parser.parser.name)
                      ->to<IR::ParserBlock>();
    BUG_CHECK(pb != nullptr, "No parser block found");
    parser = new FPPParser(this, pb, typeMap);
    bool success = parser->build();
    if (!success)
        return success;

    return true;
}

void FPPProgram::emitC(CodeBuilder* builder, cstring header) {
    emitGeneratedComment(builder);

    builder->appendFormat("#include \"%s\"", header);
    builder->newline();

    builder->target->emitIncludes(builder);

    builder->newline();
    builder->emitIndent();
    builder->target->emitCodeSection(builder, functionName);
    builder->emitIndent();
    builder->target->emitMain(builder, functionName);
    builder->blockStart();

   //builder->appendLine("void *headers = NULL;");
    builder->emitIndent();
    builder->appendLine("packet_hdr_t *last_hdr = NULL;");
    builder->emitIndent();
    builder->appendLine("packet_hdr_t *hdr = NULL;");
    //emitHeaderInstances(builder);
   // builder->append(" = NULL");
    //parser->headerType->emitInitializer(builder);
   // builder->endOfStatement(true);

    builder->emitIndent();
    builder->appendFormat("const uint8_t *%s = packet", packetStartVar);
    builder->endOfStatement(true);
    builder->emitIndent();
    builder->appendFormat("const uint8_t *%s = packet + packet_len", packetEndVar);
    builder->endOfStatement(true);
    builder->emitIndent();
    builder->appendFormat("uint64_t %s = 0", offsetVar);
    builder->endOfStatement(true);
    builder->emitIndent();
    builder->appendFormat("enum fpp_errorCodes %s = ParserDefaultReject", errorVar);
    builder->endOfStatement(true);

    emitLocalVariables(builder);
    builder->newline();

    for (auto loc : parser->parserBlock->container->parserLocals)
    {
       auto ptr = dynamic_cast<const IR::Declaration_Variable *>(loc);
       auto type = FPPTypeFactory::instance->create(ptr->type);
       if (type == nullptr)
          continue;
       type->emitType(builder);

       builder->appendFormat(" %s", loc->getName().toString());
       builder->endOfStatement(true);
    }

    builder->newline();

    for (auto loc : parser->parserBlock->container->parserLocals)
    {
       auto ptr = dynamic_cast<const IR::Declaration_Variable *>(loc);
       auto type = FPPTypeFactory::instance->create(ptr->type);
       if (type == nullptr)
          continue;

       builder->emitIndent();
       builder->appendFormat("(void) %s", loc->getName().toString());
       builder->endOfStatement(true);
    }

    builder->newline();
    builder->emitIndent();
    builder->append("*out = NULL");
    builder->endOfStatement(true);

    builder->newline();
    builder->emitIndent();
    builder->appendFormat("goto %s;", IR::ParserState::start.c_str());
    builder->newline();

    parser->emit(builder);
    emitAcceptState(builder);

    builder->emitIndent();
    builder->append(endLabel); // TODO end of function/ return code
    builder->appendLine(":");
    builder->emitIndent();
    builder->appendLine("return fpp_errorCode");
    builder->appendLine(";");
    builder->blockEnd(true);  // end of function

    builder->target->emitLicense(builder, license);
}

void FPPProgram::emitGeneratedComment(CodeBuilder* builder) {
    std::chrono::time_point<std::chrono::system_clock> now = std::chrono::system_clock::now();
    std::time_t time = std::chrono::system_clock::to_time_t(now);
    builder->append("/* Automatically generated by ");
    builder->append(options.exe_name);
    builder->append(" from ");
    builder->append(options.file);
    builder->append(" on ");
    builder->append(std::ctime(&time));
    builder->append(" */");
    builder->newline();
}

void FPPProgram::emitH(CodeBuilder* builder, cstring) {
    emitGeneratedComment(builder);
    builder->appendLine("#ifndef _P4_GEN_HEADER_");
    builder->appendLine("#define _P4_GEN_HEADER_");
    builder->target->emitIncludes(builder);
    builder->newline();

   emitPreamble(builder);
    emitTypes(builder);

    builder->append("typedef struct packet_hdr_s ");
    builder->blockStart();
    builder->emitIndent();
    builder->appendLine("enum fpp_headers type;");
    builder->emitIndent();
    builder->appendLine("void *hdr;");
    builder->emitIndent();
    builder->appendLine("struct packet_hdr_s *next;");
    builder->blockEnd(true);
    builder->append("packet_hdr_t");
    builder->endOfStatement(true);
    builder->newline();

    builder->target->emitMain(builder, functionName);
    builder->endOfStatement(true);
    builder->appendLine("#endif");
}

void FPPProgram::emitTypes(CodeBuilder* builder) {

    builder->append("enum fpp_headers ");
    builder->blockStart();
    builder->emitIndent();
    builder->append("fpp_unknown_hdr");
    for (auto d : program->declarations) {
        if (d->is<IR::Type>() && !d->is<IR::IContainer>() &&
            !d->is<IR::Type_Extern>() && !d->is<IR::Type_Parser>() &&
            !d->is<IR::Type_Control>() && !d->is<IR::Type_Typedef>() &&
            !d->is<IR::Type_Error>()) {

            auto type = FPPTypeFactory::instance->create(d->to<IR::Type>());
            auto tmp = dynamic_cast<FPPStructType *>(type);
            if (type == nullptr || tmp == nullptr)
                continue;

            builder->append(",");
            builder->newline();
            builder->emitIndent();
            builder->appendFormat("fpp_%s", tmp->name);
        }
    }
    builder->newline();
    builder->blockEnd(true);
    builder->endOfStatement(true);
    builder->newline();

    for (auto d : program->declarations) {
        if (d->is<IR::Type>() && !d->is<IR::IContainer>() &&
            !d->is<IR::Type_Extern>() && !d->is<IR::Type_Parser>() &&
            !d->is<IR::Type_Control>() && !d->is<IR::Type_Typedef>() &&
            !d->is<IR::Type_Error>()) {
            auto type = FPPTypeFactory::instance->create(d->to<IR::Type>());
            if (type == nullptr)
                continue;
            type->emit(builder);
            builder->newline();
        }
    }
}

namespace {
class ErrorCodesVisitor : public Inspector {
    CodeBuilder* builder;
 public:
    explicit ErrorCodesVisitor(CodeBuilder* builder) : builder(builder) {}
    bool preorder(const IR::Type_Error* errors) override {
        for (auto m : *errors->getDeclarations()) {
            builder->emitIndent();
            builder->appendFormat("%s,\n", m->getName().name.c_str());
        }
        return false;
    }
};
}  // namespace

void FPPProgram::emitPreamble(CodeBuilder* builder) {
    builder->emitIndent();
    builder->appendFormat("enum %s ", errorEnum.c_str());
    builder->blockStart();

    ErrorCodesVisitor visitor(builder);
    program->apply(visitor);

    builder->emitIndent();
    builder->appendLine("ParserDefaultReject,");
    builder->emitIndent();
    builder->appendLine("OutOfMemory");

    builder->blockEnd(false);
    builder->endOfStatement(true);
    builder->newline();
    builder->appendLine("#define FPP_MASK(t, w) ((((t)(1)) << (w)) - (t)1)");
    builder->appendLine("#define BYTES(w) ((w) / 8)");
    builder->appendLine("#define load_byte(ptr, bytes) (*(const uint8_t *)((const uint8_t *)(ptr) + bytes))");
    builder->appendLine("#define load_half(ptr, bytes) (*(const uint16_t *)((const uint8_t *)(ptr) + bytes))");
    builder->appendLine("#define load_word(ptr, bytes) (*(const uint32_t *)((const uint8_t *)(ptr) + bytes))");
    builder->appendLine("#define load_dword(ptr, bytes) (*(const uint64_t *)((const uint8_t *)(ptr) + bytes))");
    builder->newline();
}

void FPPProgram::emitLocalVariables(CodeBuilder* builder) {
}

void FPPProgram::emitHeaderInstances(CodeBuilder* builder) {
    builder->emitIndent();
    parser->headerType->declare(builder, parser->headers->name.name, true);
}

void FPPProgram::emitAcceptState(CodeBuilder* builder) {
    builder->emitIndent();
    builder->append(IR::ParserState::accept);
    builder->append(":");
    builder->newline();
    builder->emitIndent();
    builder->blockStart();
    builder->emitIndent();
    builder->appendLine("return NoError;");
    builder->blockEnd(true);
}

}  // namespace FPP
